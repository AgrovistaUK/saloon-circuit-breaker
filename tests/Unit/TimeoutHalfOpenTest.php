<?php

use AgrovistaUK\SaloonCircuitBreaker\CircuitBreaker;
use AgrovistaUK\SaloonCircuitBreaker\Data\CircuitBreakerConfigData;
use AgrovistaUK\SaloonCircuitBreaker\Enums\CircuitBreakerStateEnum;
use AgrovistaUK\SaloonCircuitBreaker\Services\CircuitBreakerRedisRegistry;
use Illuminate\Support\Facades\Cache;
use Carbon\Carbon;

beforeEach(function () {
    Cache::store('redis')->flush();
});

it('circuit breaker correctly reports that timeout has not been exceeded when circuit is not open', function () {
    $registry = Mockery::mock(CircuitBreakerRedisRegistry::class);
    $registry->shouldReceive('registerService')->once()->with('test');
    $config = CircuitBreakerConfigData::from(['service' => 'test']);
    $circuitBreaker = new CircuitBreaker('test', $config, $registry);
    expect($circuitBreaker->hasExceededTimeout())->toBeFalse();
});

it('circuit breaker correctly reports that timeout has not been exceeded when still within the waiting period', function () {
    $registry = Mockery::mock(CircuitBreakerRedisRegistry::class);
    $registry->shouldReceive('registerService')->once()->with('test');
    $config = CircuitBreakerConfigData::from([
        'service' => 'test',
        'timeout' => 60
    ]);
    $circuitBreaker = new CircuitBreaker('test', $config, $registry);
    $circuitBreaker->openCircuit();
    expect($circuitBreaker->hasExceededTimeout())->toBeFalse();
});

it('circuit breaker correctly reports that timeout has been exceeded after the waiting period', function () {
    $registry = Mockery::mock(CircuitBreakerRedisRegistry::class);
    $registry->shouldReceive('registerService')->once()->with('test');
    $config = CircuitBreakerConfigData::from([
        'service' => 'test',
        'timeout' => 1
    ]);
    $circuitBreaker = new CircuitBreaker('test', $config, $registry);
    $circuitBreaker->openCircuit();
    $circuitBreaker->getStatus()->metrics->circuitOpenedAt = Carbon::now()->subSeconds(2);
    expect($circuitBreaker->hasExceededTimeout())->toBeTrue();
});

it('circuit breaker allows requests within the configured half-open attempt limit', function () {
    $registry = Mockery::mock(CircuitBreakerRedisRegistry::class);
    $registry->shouldReceive('registerService')->once()->with('test');
    $config = CircuitBreakerConfigData::from([
        'service' => 'test',
        'half_open_attempts' => 2
    ]);
    $circuitBreaker = new CircuitBreaker('test', $config, $registry);
    $circuitBreaker->halfOpenCircuit();
    expect($circuitBreaker->canAttemptHalfOpenRequest())->toBeTrue();
    $circuitBreaker->executeRequest(fn() => 'attempt1');
    expect($circuitBreaker->canAttemptHalfOpenRequest())->toBeTrue();
    $circuitBreaker->executeRequest(fn() => 'attempt2');
    expect($circuitBreaker->canAttemptHalfOpenRequest())->toBeFalse();
});

it('circuit breaker blocks requests when the half-open attempt limit has been exceeded', function () {
    $registry = Mockery::mock(CircuitBreakerRedisRegistry::class);
    $registry->shouldReceive('registerService')->once()->with('test');
    $config = CircuitBreakerConfigData::from([
        'service' => 'test',
        'half_open_attempts' => 2
    ]);
    $circuitBreaker = new CircuitBreaker('test', $config, $registry);
    $circuitBreaker->halfOpenCircuit();
    $circuitBreaker->executeRequest(fn() => 'attempt1');
    $circuitBreaker->executeRequest(fn() => 'attempt2');
    expect($circuitBreaker->canExecuteRequest())->toBeFalse();
});

it('circuit breaker resets the half-open attempt counter when transitioning to half-open state', function () {
    $registry = Mockery::mock(CircuitBreakerRedisRegistry::class);
    $registry->shouldReceive('registerService')->once()->with('test');
    $config = CircuitBreakerConfigData::from(['service' => 'test']);
    $circuitBreaker = new CircuitBreaker('test', $config, $registry);
    $circuitBreaker->halfOpenCircuit();
    $circuitBreaker->executeRequest(fn() => 'attempt1');
    $circuitBreaker->executeRequest(fn() => 'attempt2');
    $status = $circuitBreaker->getStatus();
    expect($status->metrics->half_open_attempts)->toBe(2);
    $circuitBreaker->halfOpenCircuit();
    $status = $circuitBreaker->getStatus();
    expect($status->metrics->half_open_attempts)->toBe(0);
});

it('circuit breaker automatically transitions from open to half-open state after the timeout period', function () {
    $registry = Mockery::mock(CircuitBreakerRedisRegistry::class);
    $registry->shouldReceive('registerService')->once()->with('test');
    $config = CircuitBreakerConfigData::from([
        'service' => 'test',
        'timeout' => 1
    ]);
    $circuitBreaker = new CircuitBreaker('test', $config, $registry);
    $circuitBreaker->openCircuit();
    expect($circuitBreaker->getCurrentState())->toBe(CircuitBreakerStateEnum::OPEN);
    $circuitBreaker->getStatus()->metrics->circuitOpenedAt = Carbon::now()->subSeconds(2);
    expect($circuitBreaker->canExecuteRequest())->toBeTrue();
    expect($circuitBreaker->getCurrentState())->toBe(CircuitBreakerStateEnum::HALF_OPEN);
});

it('circuit breaker returns no retry time when the circuit is not in open state', function () {
    $registry = Mockery::mock(CircuitBreakerRedisRegistry::class);
    $registry->shouldReceive('registerService')->once()->with('test');
    $config = CircuitBreakerConfigData::from(['service' => 'test']);
    $circuitBreaker = new CircuitBreaker('test', $config, $registry);
    expect($circuitBreaker->getNextRetryAt())->toBeNull();
    $circuitBreaker->halfOpenCircuit();
    expect($circuitBreaker->getNextRetryAt())->toBeNull();
});

it('circuit breaker correctly calculates when the next retry attempt should be made', function () {
    $registry = Mockery::mock(CircuitBreakerRedisRegistry::class);
    $registry->shouldReceive('registerService')->once()->with('test');
    $config = CircuitBreakerConfigData::from([
        'service' => 'test',
        'timeout' => 60
    ]);
    $circuitBreaker = new CircuitBreaker('test', $config, $registry);
    $circuitBreaker->openCircuit();
    $openedAt = $circuitBreaker->getStatus()->metrics->circuitOpenedAt;
    $expectedRetryAt = $openedAt->addSeconds(60);
    $actualRetryAt = $circuitBreaker->getNextRetryAt();
    expect($actualRetryAt)->not->toBeNull();
    expect($actualRetryAt->equalTo($expectedRetryAt))->toBeTrue();
});